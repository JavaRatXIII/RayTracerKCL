\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{biblatex}
\usepackage{listings}


\title{Ray Tracer}
\title{MiddleEast Group}
\author{1720517 	Alsuwily, Norah \\ 1315403 	Qureshi, Tamanna \\
1744887 	Nandhini Sreekumar \\
1755110 	Ashokkumar, Roshini \\
1779457 	Yasin, Maryam \\
1781357 	Alotaibi, Sara }
\date{March 2018}

\begin{document}
\maketitle 

\section{Introduction}

Ray Tracing is a rendering technique which takes simple 2D objects such as circles, squares or rectangles and
produces 3D rendering of these objects in the form of spheres, cubes, cuboids etc.  by tracing the path of light as pixels on a screen space and imitating the effects of the light  with 3D objects. Scenes in ray tracer are defined mathematically by the developer. In addition, it can take data from images and models captured by means such as digital photography. \newline An advantage of ray tracing is that it gives a more realistic and desirable method of rendering. Many physically correct experience can be demonstrated with ease using a ray tracing algorithm, since the algorithm simulates the sign of light in the real world.
However, it is extremely time consuming to find the intersection between rays and geometry \cite{1}. The main issue with ray tracing is the speed. Anyhow, as computers become more quicker, it is less and less of an obstacle. Middle-east team aimed to develop a ray tracer software which rendering images based on end-user preferences which will be explained in the next sections of this report.This report will talk about ray tracer in general as well the advantages and dis-advantages of ray tracer. After that will focus on our objectives of this project. In addition, we will list project's requirements and design. As well as how we managed the team work based on the requirements, and what are the main team's process and techniques that were used to achieve our objectives.  Following by that we reviewed main sections on front-end as well as back-end implementation. An important section was mentioned in this report is the unite testing which was needed to make sure to deliver the software in an appropriate manner.Also, we have listed major points and criticized our work from technical and physical perspectives. last but not least, you will find how did the team managed and assessed each member. 

\section{Report contents}

The report is categorized as follows:
\begin{enumerate}
     

\item The review presents various other ray tracer implementations which are of use currently and has been critically analysed.
\item The requirements and design section elicits the method that the team undertook to complete the project.
\item	The Teamwork section mentions how the MiddleEast group decided to tackle the project given, along with the time line the group agreed upon. 
\item	The Processes and tools section used for the working of the project is highlighted here.
\item	The implementation details the working of the front-end Graphical User Interface and the back-end system.
\item	The Testing section elaborates on the various methods of testing that the group used to test the software critically.
\item	The Evaluation section evaluates the project critically, analysing any flaws that occurred during the course of the implementation and the approach used to deal with the flaws.
\item	The Peer Assessment section then reviews the way in which the group has agreed to divide the points among themselves, highlighting the reasons.
\end{enumerate}

\section{Review}
\subsection{What is Ray Tracer?}

\paragraph{}
To understand ray tracer you need to know what is "ray"? Basically, ray is a line that starts off at a point into a space towards some direction. When a ray hits a surface its either reflected or refracted.
In the real world, light is reflected on object surfaces until it noticed by the observer (camera or person). \newline Now, this method can not be used while using a computer to simulate a ray tracer. Hence, a revers mechanism is used where the rays are sent out from the observer viewpoint. This is much better in terms of computational speed. 
\paragraph{}
Ray tracer technique is based on an algorithm where its builds an image pixel by pixel. It casts additional rays from the hit point to determine the pixel color as shown in Figure 1.
Once the nearest object has been identified, the algorithm will estimate the incoming light at the point of intersection, examine the material properties of the object, and combine this information to calculate the final color of the pixel \cite{2}. In other words we can say that if the light hits the surface and not be blocked,  The shading of the surface is computed using traditional 3D computer graphics shading models. 
Ray tracer started before the invention of computer. 


\subsection{Beginning of Ray tracer.} 
Ray tracer started before the invention of computer. Figure 2 shows the old method of implementing the Ray tracer by Durer who is viewed as the famous designer of Northern Europe \cite{6}. After that, computers become the dominant assistant in all Three Dimension (3D) projects.

\begin{figure}
    \centering
    \includegraphics{F1.png}
    \caption{Basic ray tracing}
    \label{figure1}
    \soucre{
Source [4]}
\end{figure}

\begin{figure}[!h]
\centering
\includegraphics[scale=.6]{F2.png}
\caption{Old ray tracer method \label{fig2}}
\soucre{Source [5]}
\end{figure}

\subsection{Related Work}
\paragraph{}
A Ray tracer software by the user (ppwwyyxx ) in GitHub is based on C++ that renders a plane, sphere, mesh, flower, teapot, dragon, statue etc with the effects of reflection, translucency, rotations and zoon. Similar to our project, the software has a QT based GUI and uses Magick++ API. Upon trying the software codes on our laptops, there were compatibility issues in running Magick++ and the output wasn't perfect as what is shown as the output on the Github link. \cite{7}

Another software by (RollieRowland) in GitHub is based on Java which renders only sphere. It supports manipulating the camera, costuming the materials such as mirror, floor, glass or default one, diffusion and previewing rendering. It seems from GUI that it offers a lot of functionality, however, the major limitation here is providing different shapes and transparency. \cite{8}

A notable project which allow the user to save the rendered objects as .png File is by (abcdabcd987). It is based on C++ language which takes from the user the .json scene and provides features as reflecting, refracting, transparency and Soft Shadow. The GUI can by first downloading GLFW3 and SDL2 or can be run on remote server by xpra. \cite{9}

An important project by (captainhead) with interface built by QT. It is programmed by C++ language, and it supports Meshes and sphere shapes, reflecting and refracting spheres only. Besides the notable features provided, it lacks of shapes as well as transparency. \cite{10}

\subsection{Advantages of Ray Tracer}

Ray tracer could be classified as one of rendering methods. One main point worth to be mentioned is that the ray tracer technique is better comparing with others rendering algorithms since it has the ability of simulating the light on a real time. In addition, provides effects as reflections and shadows, which are difficult to simulate using other algorithms, and it is a default functionality on ray tracing. \cite{13}

\subsection{Disadvantages of Ray Tracer}
\begin{itemize}
    \item The major problem with the ray tracing is the speed of the algorithm. Although ray tracing can be parallelised and the technologically advanced processor cores can be used, the speed still remains a problem. \cite{14}  
\item	Another issue is the anti-aliasing. The light rays are considered as mathematical concepts and the rays are without a particular length. \cite{14}
\item	The production of not-so-photorealistic image can be considered as a drawback. When the ray tracing algorithm is correctly implemented or carefully approximated, true photorealism can be achieved. That is because every single effect of light will be considered in the algorithm \cite{13}.
\end{itemize}


\subsection{Objective}

\paragraph{}
This project aims at developing a Ray Tracer software which consists of two parts. \newline The first part is the GUI, that will allow the end users to scetch out three basic 2D shapes (Circle, Triangle, and Square) which will be converted to Sphere, Pyramid and Cube.  The program will allow the user to manipulate the sizes as well as colors. Moreover, there is also an option to select for translucency and reflectivity of the rendered object. The user interface will save the selection of the user as strings into a text file.
\newline The second part, which is the back-end system will take the input and produce  a three-dimensional rendering of the image, which will be saved as PNG file. 


\section{Design}

\subsection{Requirements}
To achieve our objectives, we needed to deliver a Ray tracer software which has  an interactive user interface which enables the user to sketch an image which the user wants to be rendered as a 3D object and the Back-end system which needs to render this 2D object in 3D. The requirements we set out to achieve our goal were to produce a front-end that enables the user to select various attributes of the object that he wants rendered in 3D (such as shape, colour, size).The backend needs to implement the ray tracer algorithm in order to provide the user with the rendered image. The interaction between the front-end and the back-end is in the form of a txt file that is saved as soon as the user confirms the specifications in the front-end which is then given to the backend as input. The final image should thus be shown to the user as a PNG file. The performance constraints that we took into consideration before working on our project is that the speed of the software should be lesser than tens of seconds. 

\subsection{Design}

The team decided to write the raytracer program using C++ since it enables the developers to write complicated programs and simplify them into parts called functions, which the team found really helpful for the design of the back-end Also, the choice of the language was due to the reason that the team is well-versed with this language and it is proved that it is fast compared to other programming languages. It has a compiling time of 1.5 seconds according to ffconsultancy \cite{3}. Here are also some other motivations for choosing C++ as the language for the implementation \cite{12}: 
\begin{itemize}
    \item 
	C++ is a highly portable language and is often the language of choice for multi-device, multi-platform app development.
\item	C++ is an object-oriented programming language and includes classes, inheritance, polymorphism, data abstraction and encapsulation.
\item	C++ has a rich function library.
\item	C++ allows exception handling, and function overloading which are not possible in C.
\item	C++ is a powerful, efficient and fast language. It finds a wide range of applications { from GUI applications to 3D graphics for games to real-time
mathematical simulations}.


And since C++ is being used as the basis of the code, the team also decided to use QT Creator : which enables users to create interactive GUI applications with ease using C++. It also provides various functionalities such as : A visual debugger, an integrated GUI layout and forms designer which is highly beneficial while developing any GUI application. Also since the requirement was to sketch an object in the front-end with various attributes (size, shape, colour) the team found QT Creator to be the ideal choice. 
The approach that the team has taken to implement our project was to make it simple for the user and hence the Graphical User Interface was implemented in such a way that the user can decide upon the size, shape, colour of the object that the user wants , in the form of a drop-down menu. To make it even simpler, the team decided to stick with 3 sizes (Scale to 50,75,90 percent) and colours can be selected from a wide range (more than 150 colours!) provided by QTCreator.

Finally, for the design of the team’s software :
\begin{itemize}
    \item 	The user can firstly select from three sizes, three shapes (Circle, Square, Triangle) and various colours using the GUI in QT Creator. 
\item	A sketch is produced of the final object, which can be passed on to the back-end system.
\item	The specifications of the object to be rendered are saved in a .txt file, that can then be taken as input by the back-end.
\item	The back-end finally takes this input and renders the image accordingly. It is then saved as a .png file for the user to view as the output.
\end{itemize}
The preliminary design decision (with the exception of using .svg file exchange format, which was later on changed to use .txt instead) was to implement using the above mentioned design plan and the team found it very straightforward and simple to implement it using the method described. The plan went on smoothly with minor obstacles, which is discussed in the evaluation section. 

The team agreed to split the responsibilities between the front-end and back-end design. Initially, the idea was to have three people working on the front-end and three people on the back-end. But upon discovering that implementation in the back-end required more work and more man-power than the front-end, the team decided to use four people to implement the back-end and two on the front-end.
\newline

\textbf{Back-End :} \newline
Nandhini Sreekumar. \newline Sara Alotaibi. \newline Tamanna Qureshi. \newline Roshini Ashokkumar.

\textbf{Front-End :} \newline
Norah Alsuwily. \newline Maryam Yasin.

The group followed a tutorial for Raytracer implementation \cite{11}. Following that, the responsibilities were agreed upon by each of the team members based on each individual’s expertise and comfort. The task was split among the 4 people in the back-end and each individual decided to deal with either a different shape, a functionality or just the general design. After which, a consensus was made during the group meeting sessions. The same applied to the front-end as well. 


\end{itemize}


\section{Team Work}
The team has decided to divide the technical work into two halves. Half of the team will work on GUI and the other half will handle the back-end system, as well as the report and the presentation. However,  the main roles and responsibilities were divided as below. Each member dedicated to achieve her tasks.
\begin{itemize}

\item \textbf{GUI and report}: Norah Alsuwily, Maryam Yasin, Sara Alotaibi. 
\item \textbf{Back-end and presentation}: Roshini Ashokkumar, Nandhini Sreekumar, Tamanna Qureshi. 
\end{itemize}
This way we are able to efficiently manage the load of this project to ensure that every team member is allocated with balanced workload. Thus, ensuring that the project proceed smoothly and successfully.



At the beginning of this project the Middle-East team sat a plan to follow as you can see in below table. 
\newline
\begin{center}
\begin{tabular}{|c|c|c|} 

\hline
\textbf{Week no.} & \textbf{Week Date } & \textbf{To-do } \\ 
\hline
Week 1 & 14 January  & Brainstorming \\ 
\hline
Week 2 & 21 January  & Discussion  on tools and language to be used. \\ 
\hline

Week 3 & 28 January & Search and share knowledge. \\
 & & Also, starting with GUI and Back-end system. 
 \\ 
\hline
Week 4 & 4 February & Finalizing the initial report and presentation.  \\ 
\hline
Week 5 &  11 February & Working on the software (GUI and Back-end)  \\
\hline
Week 6 & 18  February & Working on the software (GUI and Back-end)   \\ 
\hline
Week 7 & 25  February & Working on the software (GUI and Back-end)   \\ 
\hline
Week 8 & 4 March  & Working on the software (GUI and Back-end)   \\  
 & & + Working on the final report. \\   
\hline
Week 9 & 11 March  & Testing and handling errors. + Working on the final report.   \\ 
\hline
Week 10 & 18 March  & Preliminary final report. \\ 
\hline
Week 11 & 25 March  & *Finalizing the project  \\ 
 &  & Report Submission and Presentation  \\

\hline

\end{tabular}
\end{center}
    



*(Check the system is running successfully and practice for the presentation) 
 


\subsection{Processes and Tools}

This section tells about the team's operations and tools used to manage the work as below.   
\begin{itemize}

\item Meeting and Communication: Team groups in every project need to communicate in a formal way to follow the time line and watch the progress for their project. As well as negotiate and get feedback to enhance and reflect team’s suggestions. To do that we used couple of applications like Slack and Whatsapp to be up to date. As well as physical meetings in the college, which was every Tuesday at 1 O’clock since it suites all team members to meet and discuss previous and next agenda. 
\item Development: Our system was divided into parts where we used to two softwares to develop the code. We chose QT creator and CodeBlock since they are:
\begin{itemize}
\item 	Easy to use.
\item	No need to use another program where you can compile within the same software.
\item Data visualization where 

\end{itemize}
\item Documentation: Each project needs to be documented and presented in a good way. There are many documentation programs, however, we chose Latex and Powerpoint since they satisfy college requirement, free and easy to use. 

\end{itemize}



\subsection{Meeting Management} 
Team has agreed to meet regularly every week on Tuesday and divide the tasks fairly according to each teammate's skills. The progress will be monitored every week and comments from every team member will be adhered to. \newline If there are any personal circumstances that will prevent the teammates from completing the task, she will need to follow it up in the following week and failure to do so, will definitely reflect on her marks based on Berger algorithm at the end of the project as the marks are based on her work and efforts that she has put into this project in this way we can efficiently handle peer assessment without any conflicts. 



\section{Implementation}

To start working with ray tracer software we had to learn the basic concepts of ray tracer and its structure. Many sites and tutorials helped us to build our knowledge and  have better understanding. After gaining knowledge, we started working on the main parts of the program separately. The functionalities were divided at the beginning and we had met weekly to enhance and merge the codes.  

\subsection{Front-end Implementation}
\paragraph{} The front-end system was built through QT creator software. It is a cross-platform integrated development environment (IDE) to develop mobile, desktop and embedded applications using C++. It is being widely used by developers due to its simple and intuitive interface.   

The Graphical user interface has several features as: 

\begin{itemize}
    \item SHAPE
    \newline
    The user can alter the active shape(Shape) to three basic shapes including Circle, Square and Triangle. 
    
    \begin{figure}[!h]
\centering
\includegraphics[scale=.5]{Sh1.png}
\caption{Shapes down list \label{shape}}
\end{figure}


    \item SIZE
    \newline
    The shapes can be adjusted to 3 different sizes (in terms of x and y pixel units). \newline
Default size: \newline
Circle: (250.0,250.0) \newline
Square: (250.0,250.0) \newline
Triangle: (200.0,100.0),  (100.0,300.0), (300.0,300.0)

Scale to 50 percent:
Increases the co-ordinates in Default setting by 50 percent for each of the shapes.

Scale to 75 percent:
Increases the co-ordinates in Default setting by 75 percent for each of the shapes.

Scale to 90 percent
Increases the co-ordinates in Default setting by 90 percent for each of the shapes.

\begin{figure}[!h]
\centering
\includegraphics[scale=.6]{S1.png}
\caption{Sizes drop down list \label{Size}}
\end{figure}


\paragraph{}
For scaling, QT’s QPainter(see QT classes)manipulates the coordinate system to perform scaling. These coordinates are passed to the backend where they are converted into the vector scale where each 100-pixel unit corresponds to approximately 1 vector unit. In terms of size transformation at the backend, our project uses an approximate conversion metric.

\item COLOR \newline
The user can choose a colour from a list of colours that are available in QT’s Colornames() function. Colornames() comes with a large number of colour names that make it easier for the user to pick a colour shade as evident from the name itself, instead of having to try and test different colours from the RGB colour picker. This was an important decision for us when designing the user interface as we wanted to make the application’s interface simple, easy and user friendly.

\begin{figure}[!h]
\centering
\includegraphics[scale=.6]{C1.png}
\caption{Colors drop down list \label{Color}}
\end{figure}

\end{itemize}

As we have not use any standard library, we have used below two QT classes:
 \begin{itemize}
     \item QPainter \newline
     QPainter performs low-level painting on widgets. This class can create simple lines to complex shapes like pies and chords. The traditional drawing uses a natural co-ordinate system supported by QT where the top left corner is 0,0(x, y). To display the content according to the display widget’s size we have translated the coordinate system to a (160,50) scale so that the shape is drawn from that point as the initial x and y co-ordinates (0,0). 
     \item QPainterPath \newline
     This class enables painting operations allowing for graphical shapes to be drawn and reused. Our program uses three of its functions to add closed shapes to a Painterpath: addRect(), addEllipse(),addPolygon(), to draw a Circle, Square and a Triangle with different set of points to draw the desired shape.
     
Other classes that our program has used in our Widgets application include <QComboBox>,<QPushButton>,<QWidget> to add various selection/input widgets to our interface allowing for user interaction. 

 \end{itemize}
 
 The front-end was implemented on the following manner: 
 \begin{enumerate}
     \item	Our frontend consists of two classes:
A, Renderer is a custom widget that renders the currently active shape
B, AppWindow is the application’s main window displaying a Renderer widget in addition to several parameter widgets

\item	As part of the final raytraced object, the user can choose if they want the shape translucent and/or reflective respectively. 
\item	QT has a Signals and Slots functionality that allows actions on widgets to be connected to different slots(methods) that allow for fast, integrated object communication. For instance, the shapeSelected() slot gets called when the user changes the shape from the corresponding comboBox
\item	Once the user has made selections, the program uses QWidget’s paintevent() function to draw the currently active shape as per the specified parameters. For instance, if the user selects a circle, QPainterPath’s (see QT classes) addEllipse() function will draw an ellipse according to the specifies points in our program, that is, (250,250)
\item	Once the result is shown on the display widget, the user has the option to save the information presented in the comboBoxes into a text file. The program notifies the user upon saving the file.
\item	At any point in the interface, the user can make changes to their selection which immediately reflect on the display widget. 

 \end{enumerate}
 
 
\subsection{Back-end Implementation}
The back-end system was built through CodeBlocks software, in help with learning tutorial [2]. Basically, it receive a text file from the front-end and it will read it as variables. These variables will be converted to data values that can be used to draw the shape in terms of the size and other aspects of the shape.  

Following points will shows an important sections on the back-end system.

\begin{enumerate}

\item Below code shows how to read the data from text file that was pushed from the front-end. This was in to enable us to manipulate the data to be able to draw shapes.

In addition, a problem occurred when trying to run the code in different machines, as the user name will be changed according to the user’s machines name causing the directory used in the code to be incorrect. To resolve this problem we used DWORD type, as it will take the user name’s length from the system. In addition, we used GetUserName method where it use character array and the user name’s length to retrieve the user’s machine name. 


     \begin{lstlisting}
string output;
       string shape = "";
       string scale = "";
       double shapeSize = 0.5;
       string color = "";
       string translucent = "";
       string reflection = "";

       char uname[UNLEN+1];
       DWORD username_len = UNLEN+1;
       GetUserName(uname, &username_len);
       string username(uname);

       std::stringstream ss;
       //ss << "C:\\Users\\" << username << 
       "\\Documents\\A Kings\\Group Work\\RayTraceFrontEnd\\Scene.txt";
       ss << "C:\\Users\\" << username <<
       "\\Documents\\GitHub\\RayTracerKCL\\RayTraceFrontEnd\\Scene.txt";
       std::string fileLocation = ss.str();

       ifstream myReadFile;
       myReadFile.open(fileLocation);

       int i = 0;

       if (myReadFile.is_open())
       {
           while (!myReadFile.eof())
           {
               for(i; i < 5; i++)
               {
                   getline(myReadFile,output);
                   if(i == 0)
                   {
                       shape = output;
                       break;
                   }
                   else if (i == 1)
                   {
                       scale = output;
                       break;
                   }
                   else if(i == 2)
                   {
                       color = output;
                       break;
                   }
                   else if(i == 3)
                   {
                       translucent = output;
                       break;
                   }
                   else
                   {
                       reflection = output;
                       break;
                   }
               }
           i++;
           }
       }



     \end{lstlisting}

\item  Another section in the code, where it implement all the intersections and makes the object visible in the scene, so it will not show as a black scene.  It does the light intersections with the object so that they have shading. It also has the second hand intersection where it enables surfaces to be reflective.  
\begin{lstlisting}

Color intersection_color = getColorAt(intersection_position,
intersecting_ray_direction, scene_objects,
index_of_winning_object,
light_sources, accuracy, ambientlight); \end{lstlisting}

\item One important variable is (aadepth) where it does the anti-aliasing function making the images smoother. In that way we do not have edges on a smooth surface.  Basically, this variable will start from value (1) and above. But the higher the value, the more time it will take to render the image and effecting the processing time. And although, the image will be nicer and smoother, it will take too long to render the image as it will take over 10 seconds to create the image.  Therefore, we settled to maintain the value at 1.
\begin{lstlisting}
int aadepth = 1;
\end{lstlisting}

\item Important thing to mention is below code since our program depends on saving PNG images. To do this we had to use below method to convert PPM into PNG, as there are no standard libraries which provide this functionality. 
\begin{lstlisting}
savepng("scene.png",width,height,dpi,pixels);
\end{lstlisting}


\item The Object Class is the parent class to all other object classes, so it will not be possible to have other objects in the scene without this class. The Sphere and Plane classes are children of the Object class and the Cube and Pyramid are implemented using the Triangle class, which in turn is a child class of the Object class.

\begin{lstlisting}
class Object {
    public: 

    Object (); 

    
    virtual Color getColor () { return Color (0.0, 0.0, 0.0, 0); } 
    virtual Vect getNormalAt(Vect intersection_position) {
        return Vect (0, 0, 0);
    }

   // function that returns ray intersection
    virtual double findIntersection(Ray ray) {
        return 0; // for no objects intersection is 0
    }

}; \end{lstlisting}

\item Lightning functionality is one of the most important functionalities in every ray tracer program. Below code enables the software to reflect the light on the objects and produce the rendered image as how the user wants.

\begin{lstlisting}

Vect light_direction = light_sources.at(light_index)->
getLightPosition().vectAdd(intersection_position.negative()).normalize(); 

\end{lstlisting}

\item Below section of the program obtain the camera position which represent the sight of the viewer. These methods facilitate seeing any of the rendered image. 

\begin{lstlisting}
Vect getCameraPosition () { return campos; }
    Vect getCameraDirection () { return camdir; }
    Vect getCameraRight () { return camright; }
    Vect getCameraDown () { return camdown; }
    
 \end{lstlisting}
 
 \item To be able to set ray intersection we used below code. This determines ray intersection with plane so if the plane gets intersected it is possible for the other objects to be intersected with. However, if the plane does not get intersected with the light then the other objects will also never be intersected the light which means that other objects will be forever invisible.
 
 \begin{lstlisting} 
 
 virtual double findIntersection(Ray ray) {
   Vect ray_direction = ray.getRayDirection();

   double a = ray_direction.dotProduct(normal); 
   

   if (a == 0) {
      return -1;
   }
   else {
            double b = normal.dotProduct(ray.getRayOrigin()
            .vectAdd(normal.vectMult(distance)
            .negative()));
            return -1*b/a; }
 
 \end{lstlisting}
 
 \item The ray is needed to determine where the light is going and which direction it is from. Using the getRayOrigin method we can direct the ray source in the source class to make sure it is in front of the objects and not behind the objects which will allow the  objects to be visible.
 
 \begin{lstlisting}
 Ray ();
Ray (Vect, Vect);

    Vect getRayOrigin () { return origin; }
    Vect getRayDirection () { return direction; }
 \end{lstlisting}
 
 \item 
 An important feature in any ray tracer program is the lighting. Below code shows the light positions and the colour for the light source in the source class. This sets the light source position at the standard origin in the program (top left) so that the objects which show at the standard origin of the image (centre), so that the objects are always intersected and visible after using the light, source, ray and object class. Moreover, there is also the method called getLightColor. This adjust the colour of the light. For example, if it was set to green we would only have been able to see green objects. For that, we had set the light colour to white.
 
 \begin{lstlisting}
 virtual Vect getLightPosition() {return Vect(0, 0, 0);}
virtual Color getLightColor() {return Color(1, 1, 1, 0);}
 \end{lstlisting}
 
\end{enumerate}



 \newpage
\subsection{Testing}
Any project need to be tested in different ways to make sure that it meets the project’s objectives. For that we demonstrated several case scenarios to check the performance and the result of the program. \newline



\textbf{Front-end Testing:}

\begin{itemize}
    \item First case scenario: \newline
    User will Select square shape, scale 75 percent, in palevioletred color. There will be no transparency but there will be reflectivity. As you can see in Figure 4, the result from the front end will be saved as a text file and will be used as an input by the back-end for ray tracing. 
    
    \begin{figure}[H]
\centering
\includegraphics[scale=.5]{T7.png}
\caption{First case scenario's input \label{test1}}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[scale=.5]{T7-7.png}
    \caption{First case scenario's result}
    \label{test1}
\end{figure}

\end{itemize}


\textbf{Back-end Testing: } 

\newline

\begin{itemize}
    \item Second case scenario: \newline
    User will choose Square shape, scale 25 percent, in pink color. There will be no transparency, but there will be reflectivity. 
    
   \begin{figure}[H]
\centering
\includegraphics[scale=1]{T1.png}
\caption{Second case scenario's input \label{test2}}
\end{figure}

 
 \begin{figure}
    \centering
    \includegraphics{T1-1.png}
    \caption{Second case scenario's result}
    \label{test2}
\end{figure}



\item Third case scenario: \newline
User will choose Circle shape, scale 50 percent, in Purple color. There will be a transparency and reflectivity. 

\begin{figure}[H]
\centering
\includegraphics[scale=.5]{T2.png}
\caption{Third case scenario's input \label{test3}}
\end{figure}

\begin{figure}
    \centering
    \includegraphics{T2-2.png}
    \caption{Third case scenario's result}
    \label{test3}
\end{figure}

\item Forth case scenario: \newline
User will choose Circle shape, scale 100 percent, in Purple color. There will be no transparency but there will be reflectivity.

\begin{figure}[H]
\centering
\includegraphics[scale=.5]{T3.png}
\caption{Forth case scenario's input \label{test4}}
\end{figure}

\begin{figure}
    \centering
    \includegraphics{T3-3.png}
    \caption{Forth case scenario's result}
    \label{test4}
\end{figure}

\item Fifth case scenario: \newline
User will choose Circle shape, scale 0 percent, in yellow color. There will be no transparency but there will be reflectivity. 
Be noted that 0 percent will be converted automatically to 100 percent. 



\begin{figure}[H]
\centering
\includegraphics[scale=.5]{T4.png}
\caption{Fifth case scenario's input \label{test5}}
\end{figure}

\begin{figure}
    \centering
    \includegraphics{T4-4.png}
    \caption{Fifth case scenario's result}
    \label{test5}
\end{figure}

\item Sixth case scenario: \newline
User will choose Triangle shape, scale 25 percent, in darkviolet color. There will be no transparency nor reflectivity. 

\begin{figure}[H]
\centering
\includegraphics[scale=.7]{T5.png}
\caption{Sixth case scenario's input \label{test6}}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[scale=.5]{T5-5.png}
    \caption{Sixth case scenario's result}
    \label{test6}
\end{figure}

\item Seventh case scenario: \newline
User will choose Square shape, scale 17 percent, in darkviolet color. There will be no transparency nor reflectivity. Be noted that the scale will be converted automatically to 100 percent as well.

\begin{figure}[H]
\centering
\includegraphics[scale=.7]{T6.png}
\caption{Seventh case scenario's input \label{test7}}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[scale=.5]{T6-6.png}
    \caption{Seventh case scenario's result}
    \label{test7}
\end{figure}

\end{itemize}



 \newpage
\newpage


\section{Evaluation}

An important phase in any project is to evaluate and criticized the work. This helps team members to identify project's issues and prepare to tackle them in appropriate way. By analyzing the team work we come up with several points as you can see below:
\begin{enumerate}
    
    \item 	The initial plan was to use SVG file format, which after careful consideration and also taking the suggestion provided by the supervisor, the decision was changed to use txt file instead. This was one of the few things that took us long to research and we would say didn’t go well initially. We then experimented with txt files and found them to be much more simpler to use and therefore made us reach the conclusion to include this in our project. 
\item 	 The other design issue in the front end was to enable the user to control the size of  object in the scene. The original idea was to provide a set of 10 values of x and y co-ordinates to the user, which they can type and submit (say; x=20,y=30...). But this caused issues with respect to the design of the back-end as they would need multiple cases involving all the co-ordinates input separately.Thus deteriorating performance as well. Therefore the team decided to switch to a simpler mechanism of allowing the user to have 4 sizing options which will eliminate the need to write multiple if statements in the back-end as well as making it convenient for the user without confusing the individual. It also increased the responsiveness of the overall software as a whole.  
\item 	There was a problem with the option of choosing colors for the objects. The set out plan was to use a colour picker which is provided to the user which enables the user to pick the colour of choice using RGB values in the form of a slider.  The problem with this particular plan was that there needed to be a vast amount  of colour RGBA values that needed to be hard-coded into the program making this very inefficient according to our expertise. Therefore we switched to a colour list which QTColornames provided with a few basic colours which we are currently using in our implementation. These colours are also compatible with other services and formats such as HTML,CSS to name a few. 
\item 	With respect to the backend, there was an issue with the shading of the image where the variable could not be recognised by the program to produce the necessary translucency in the final rendering of the image of the ray tracer. We then tried declaring the variable as a global variable to alleviate the issue which raised another issue wherein there were disturbances caused in the intersections of lights in the  ray tracer itself. Thereby leading us to make a decision to abondon shading as a whole to eliminate this major issue that rose. Please see Figure ~\ref{point4a} and ~\ref{point4b} . 
\begin{figure}[h]
\centering
\includegraphics[scale=.4]{E4.png}
\caption{Shading issue before getting solved \label{point4a}}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[scale=.4]{E4A.png}
\caption{Shading issue after getting resolved \label{point4b}}
\end{figure}

\item 	There was also another concern with the txt file being able to not accept the strings generated using the Qstring class of QTCreator. The values were not able to be accepted by the backend because it was not able to accept the Qstring values as they were abstract and the string values used in the backend were concrete. This problem was then overcome by converting the string values in the frontend fom Qstring to string before pushing it to the txt file, thereby enabling the backend to read and manipulate the values effectively.
\item 	There was a difficulty with implementing the lighting in the image using the raytracer , this was due to the fact that the light was not able to reflect the surface of the image and it lead to the colours of image being inverted (For example, a green sphere reflected purple where the light hit it’s surface due to this problem). This was dealt with by adjusting the lighting level and colours so it would reflect white instead of it being reflected as the inverted colour. Please see Figure ~\ref{point6a} and ~\ref{point6b} . 
\begin{figure}[!H]
\centering
\includegraphics[scale=.4]{E6.png}
\caption{Lighting issue before getting solved \label{point6a}}
\end{figure}

\begin{figure}[!H]
\centering
\includegraphics[scale=.4]{E6A.png}
\caption{Lighting issue after getting resolved \label{point6b}}
\end{figure}

\item The core thing of this project are the team members. At the beginning we had an issue to have a common time slot that is convenient for all members since the team members are from different programs and have different schedules. We have 2 hours in common that we could fit in during the week. Therefore, we came up with an agreement to meet and set a plan and revise the agenda and divide the work. Whenever there was a need to finish more work, we agreed to meet after working hours or during the weekend to make sure the project is completed within the given time.  

\item During the testing of the software the team had difficulties linking the front-end to the back-end. This occur while merging the whole back-end code with the front-end code which cause issues with saving the inputs and lack of some libraries duo to changing the machine and the software. However, we were able to manage this by adding another user interface by calling both front-end and back-end, after that we were able to synchronize them together.

\paragraph{} The primary design plan was to build a simple raytracer which can render simple shapes such as a square and a circle into a cube and a sphere respectively. We decided as a team to implement these two shapes in our project initially before moving on to implement other shapes. We were on track with our plan and this lead us to add another shape in our raytracer, a triangle (rendered as a pyramid) which was not part of our plan but we decided to include it. 

While some of these changes were forced upon us (For example : all of the backend issues such as the translucency, the string and the colouring issue) while some of them were because of improved thinking from our side and also due to the useful advice from the supervisor. These changes enabled us to improve our program to run efficiently and also improve the performance manifold and this was the main reason behind these design decisions that were taken. 

All of these decisions were taken as a team after careful consideration and after listening to each team member’s opinion on the matter and research as well. There were never any disputes that arose due to these as we made sure every member’s opinion was heard and taken into account before reaching a conclusion. We regularly discussed about these decisions during our team meetings as well as on other virtual setups such as Whatsapp and Slack to maintain communication does not cease to exist 

The team made sure that the plan for the project was a feasible one therefore making sure it is realistic so we could not include many of the features we had in mind such as the colours issue and the range of values issue as mentioned above. These were some minor changes which we would love to add to our project in the future to make sure that it is extensible and as interactive with the user as possible. We would also have implemented more shapes such as meshes and other polygonal shapes if we could accommodate it during the time given, which is also definitely something that could be improved upon in the future.

\end{enumerate}
\newpage

\section{Peer Assessment}
As a team we have collaborated with each other to make sure that we accomplish our assignment successfully.  Each member has contributed with their effort and knowledge to ensure delivering the tasks in the right time, and without a single member of this team, this would not be completed. Based on member’s work we divided 100 points equivalently. The below table lists team members' names alphabetically with their deserved points.  

\begin{center}
\begin{tabular}{ |c|c|} 
\hline
\textbf{Name} & \textbf{Points }  \\ 
\hline
Maryam Yasin  & 16.66 Points    \\ 
\hline
Nandhini Sreekumar  &  16.66 Points   \\ 
\hline

Norah Alsuwily  & 16.66 Points  
 \\ 
\hline
Sara Alotaibi & 16.66 Points  \\ 
\hline
Roshini Ashokkumar  &  16.66 Points \\ 
\hline
Tamanna Qureshi  & 16.66 Points  \\ 
\hline

\end{tabular}
\end{center}

\section{Conclusion and future work}

The team have been successful in developing a ray tracer software according to the requirements and objectives the group had at the beginning of this project. The most significant parts of the software have been demonstrated and the project has been criticized in depth. 
This report also shows how the team worked together in creating a simple ray tracer software. 
As future work, more complicated shapes and sizes can be added. As well, enhancing the clarity of the objects could be done. Also, it can be considered to improve the responsiveness of the user interface. Last but no least, the performance of the software could be boosted. 

\newpage


\begin{thebibliography}{9}

\bibitem{1}
  \textit{\LaTeX: "URL: scratchapixel.com"}
  
\bibitem{2}
{\LaTeX: "URL:blog.world-mysteries.com"}
  

\bibitem{3}
{\LaTeX: "URL:http://www.ffconsultancy.com/ocaml/ray_tracer/languages.html"}

\bibitem{4}
{\LaTeX: "http://i.imgur.com/YPSKk.png"}

\bibitem{5}
{\LaTeX:"URL:https://www.researchgate.net/figure/Albrecht-Duerer-method-of-perspective-construction-in-Underweysung-der-Messung-1525_fig1_281085415"}

\bibitem{6}
{\LaTeX: "URL:https://www.nationalgallery.org.uk/artists/albrecht-durer"}


\bibitem{7} {\LaTeX: "URL:https://github.com/ppwwyyxx/Ray-Tracing-Engine"}

\bibitem{8} {\LaTeX: "URL:https://github.com/RollieRowland/JavaFX-Ray-Tracer"}

\bibitem{9} {\LaTeX: "https://github.com/abcdabcd987/ray-tracing"}

\bibitem{10} {\LaTeX: "https://github.com/captainhead/Raygun"}

\bibitem{11}
{\LaTeX:"URL:https://www.youtube.com/watch?v=k_aRiYSXcyo"}

\bibitem{12}
{\LaTeX:"https://www.quora.com/What-are-the-advantages-of-C-over-C-and-vice-versa"}


\bibitem{13}
{\LaTeX:"https://en.wikipedia.org/wiki/Ray_tracing_(graphics)#Advantages_over_other_rendering_methods"}

\bibitem{14}
{\LaTeX:"http://www.tomshardware.com/reviews/ray-tracing-rasterization,2351-7.html"}


\end{thebibliography}
\end{document}
